接下来近期的安排：
    8.28 号并发结课
    8.29 考试
    8.30 开前端的课
         数据库
         django
         flask
         tornado
         scripy


课程回顾:
    线程池
    队列：同一进程内的队列
      先进先出    后进先出    优先级队列

    线程池中的回调函数是谁在调用？
       线程池中的回调函数是子线程调用的，和父线程没有关系
       进程池中的回调函数是父进程调用的，和子进程没有关系



今天的内容：
     为什么要有协程？

        因为想要在单线程内实现并发的效果。
          因为CPthon有GIL锁，限制了在同一个时间点，只能执行一个线程
          所以想要在执行一个线程的期间，充分的利用CPU的性能
          所以才有了想在单线程内实现并发的效果。
        并发：切换+保存状态
        cpu是为什么要切换？
           1 因为某个程序阻塞了
           2 因为某个程序用完了时间片
           很明显  解决1 这个问题才能提高效率
        所以想要实现单线程的并发，就要解决在单线程内，多个任务函数中，某个任务函数遇见IO操作，马上自动切换到其他任务函数去执行。

     协程：是一个比线程更加轻量级的单位，是组成线程的各个函数
       协程本身没有实体
     greenlet模块：能简单的实现函数与函数之间的切换，但是遇到IO操作，不能自动切换到其他函数中
        （1） 注册一下函数func，将函数注册成一个对象f1
              f1 = greenlet(func)
        （2） 调用func，使用f1.switch()，如果func需要传参，就在switch这里传即可

     gevent模块：可以实现在某函数内部遇到IO操作，就自动的切换到其他函数内部去执行
         g = gevent.spawn(func，参数) 注册一下函数func，返回一个对象g
         gevent.join(g) #等待g指向的函数func执行完毕，如果在执行过程中，遇到IO，就切换
         gevent.joinall([g1,g2,g3])#等待g1 g2 g3指向的函数func执行完毕

   大的总结：协程是由用户自己去调度的，
       面试题：
       已经学习过了进程，线程，协程
         计算密集用多进程，可以充分利用多核cpu的性能，
         IO密集用多线程（注意，协程是在单线程的）
       多线程和协程的区别是：
         线程是由操作系统调度，控制
         协程是由程序员自己调度，控制

     IO多路复用
        阻塞IO
        非阻塞IO
        多路复用IO
        异步IO python实现不了，但是有tornado框架，天生自带异步

     面试题：
       select  和    poll    和epoll的区别

      select和poll有一个共同的机制，都是采用轮训的方式去询问内核，有没有数据准备好了
      select有一个最大监听事件的限制，32位机限制1024，,6位机限制2048
      poll没有，理论上poll可以开启无限大，1G内存大概够你开10W个事件去监听

      epoll是最好的，采用的是回调机制，解决了select和poll共同存在的问题
      而且epoll理论上也可以开启无限多个监听事件



并发的本质：切换 + 保存状态







