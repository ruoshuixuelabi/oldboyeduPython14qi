复习：
    C/S架构：客户端 服务器模式
    B/S架构：浏览器 服务器模式
       B/S架构的客户端对PC机的性能要求比较低。统一了应用的接口
       B/S架构隶属于C/S架构
    TCP UDP的区别：
       TCP 面向连接，可靠的，面向字节流
       UDP 不面向连接，不可靠的，速度快，面向数据包的
    TCP会发生粘包：
       粘包：数据混乱。发送端发送了数据后，接收端不知道应该如何去接收，导致数据混乱
         合包机制：Nagle算法
         拆包机制
       注意：只有TCP协议才会发生粘包
    arp协议：通过目标的IP地址获取到目标的MAC地址。
    OSI五层模型：
       应用层        http，https，ftp
       传输层        tcp，udp
       网络层        ip协议
       数据链路层    arp协议            网卡，
       物理层                           网线，电信号，集线器

    交换机和路由器的区别？
       交换机主要用来组织局域网，进行同一网段之间的信息传输
       路由器：主要用来跨网段的信息传输，路由出最佳路径

    交换机的通信方式：
       单播：点对点
       广播：吼一嗓子，
       组播：点对多（一组或者多台）

    如何判断两个电脑是否处于同一网段？
       子网掩码 & ip地址

    并行和并发？
       并行：同一时间点多个任务同时进行
       并发：在同一时间段内多个任务同时进行

    进程和线程的区别？
       进程：是资源分配的基本单位
       线程：是最小的执行单位，线程不能独立拥有资源，必须依赖于所属进程。
       当计算密集时，多进程比较好。IO密集时，使用多线程。

    GIL锁：全局解释锁。锁的是线程。保证同一时间只允许一个线程访问CPU
    互斥锁：一把锁配一把钥匙。主要用于保护数据安全。
          共享资源，又叫做临界资源。共享代码，又叫做临界代码。
          对临界资源进行操作时，一定要加锁。
    递归锁：一把万能钥匙配好多把锁。

    信号量：
        也是用来保护数据安全。
        一把锁配多把钥匙

    事件：
        wait（） 判断is_set的bool值，如果为True，wait是非阻塞。
        set      将is_set的bool值设置为True
        is_set   标识
        clear    将is_set的bool值设置为False

    多线程里还学了：
        条件
        定时器：Timer（t，func）

    多进程之间的通信：
        队列和管道
        队列是安全的。  队列 = 管道+锁
        管道是不安全的。

    队列实现的生产者消费者模型。
        这个模型主要是为了解耦。

    进程池的模块：Pool
        p.map（）
        p.apply():同步提交任务
        p.apply_async（）:异步提交任务
        回调函数：在进程池中，是父进程调用的回调函数。

今日内容：
     1   同一个进程内的队列（多线程）
         import queue
         queue.Queue()  先进先出
         queue.LifoQueue() 后进先出
         queue.PriorityQueue()  优先级队列
            优先级队列 q = queue.PriorityQueue()
               q.put()  接收的是一个元组
               元组中第一个参数是：表示当前数据的优先级
               元组中第二个参数是：需要存放到队列中的数据
            优先级的比较（首先保证整个队列中，所有表示优先级的东西类型必须一致）
               如果都是int，比数值的大小
               如果都是str，比较字符串的大小（从第一个字符的ASCII码开始比较）

     2   线程池
         在一个池子里，放固定数量的线程，这些线程等待任务，一旦有任务来，就有线程自发的去执行任务。

     #  concurrent.futures 这个模块是异步调用的机制
     #  concurrent.futures 提交任务都是用submit
     #  for + submit 多个任务的提交
     #  shutdown 是等效于Pool中的close+join，是指不允许再继续向池中增加任务，然后让父进程(线程)等待池中所有进程执行完所有任务。

     如何把多个任务扔进池中？
       

     不同的方式提交多个任务（for+submit  或者 map），拥有不同的拿结果的方式
       如果是for+submit的方式提交任务，拿结果用result方法
       如果是map的方式提交任务，结果是一个生成器，采用__next__()的方式去拿结果


     关于回调函数，不管是Pool进程池的方式，还是ProcessPoolExecutor的方式开启进程池，
         回调函数都是由父进程调用
     关于回调函数，ThreadPoolExecutor
         回调函数是谁调用？？？？